# 实现原则

核心设计决策及其原因。

## 为什么选择Jackson ObjectMapper

| 原因 | 说明 |
|------|------|
| **业界标准** | Spring Boot默认集成，零额外依赖 |
| **零维护** | 自动处理新字段，无需手动更新映射 |
| **类型安全** | 编译时泛型检查，运行时自动转换 |
| **性能优秀** | 内部缓存优化，毫秒级转换 |
| **复杂支持** | 自动处理嵌套、集合、继承 |

## 为什么三层参数覆盖

| 层级 | 为什么需要 | 使用场景 |
|------|------------|----------|
| **服务层** | 业务灵活控制 | 活动定制、用户偏好 |
| **数据库** | 运维可配置 | 环境差异、A/B测试 |
| **代码层** | 兜底保障 | 默认值、向后兼容 |

### 覆盖顺序原因
- **服务层最高**: 业务需求优先
- **数据库次之**: 配置化管理
- **代码层兜底**: 确保可运行

## 为什么使用泛型方法

| 传统方式问题 | 泛型解决方案 |
|--------------|--------------|
| 每个工具写一个方法 | 一个方法适配所有 |
| 新工具需改框架 | 零框架修改 |
| 类型转换易错 | 编译时类型安全 |
| 代码重复率高 | 复用率100% |

## 为什么ThreadLocal

| 需求 | ThreadLocal优势 |
|------|-----------------|
| **并发隔离** | 每线程独立参数 |
| **跨方法传递** | 无需修改方法签名 |
| **生命周期控制** | finally确保清理 |
| **性能优秀** | 无锁设计 |

## 为什么不可变对象

| 可变对象问题 | 不可变对象优势 |
|--------------|----------------|
| 并发修改风险 | 线程安全 |
| 状态难追踪 | 状态明确 |
| 防御性拷贝 | 无需拷贝 |
| GC压力大 | GC友好 |

## 设计原则总结

### 高层关注点
- **变量名是高层设计**: 使用反射而非硬编码
- **业务逻辑优先**: 技术服务于业务
- **扩展性第一**: 新功能零框架修改

### 技术选型原则
- **成熟优于创新**: Jackson > 自定义反射
- **简单优于复杂**: 三层覆盖 > 复杂继承
- **显式优于隐式**: 明确的优先级顺序

### 代码质量原则
- **DRY**: 通用方法消除重复
- **SOLID**: 单一职责，依赖倒置
- **KISS**: 保持简单直接